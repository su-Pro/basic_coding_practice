# [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

## solution 

### 1. goal & basic case

- ***goal?*** 
具有最大和的连续子数组(长度不限)

- ***basic case?*** 
连续子数组只有一个元素，则和为当前元素的值
### 2. growing & relation 

- ***growing***

a. 根据题意和basecase 初始化表格：

| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| array  | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |
| dp_map | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |


b. index 1

case 1 : [- 2，1] --> 合 -1
case 2 : [1] --> 合 1

根据题意，此处表格应该填case 2 的值

| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| array  | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |
| dp_map | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |

c. index 2

case 1 : [1，-3] --> 合 -2
case 2 : [1，-3，-2] --> 合 -4
case 3 : [-3] --> 合 -3

根据题意，此处表格应该填case 

| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| array  | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |
| dp_map | -2  | 1   | -2  | 4   | -1  | 2   | 1   | -5  | 4   |

c. index 3

case 1 : [4，-3] --> 合 1
case 2 : [4，-3，1] --> 合 2
...
case x : [4] 

根据题意，此处表格应该填case x


| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| array  | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |
| dp_map | -2  | 1   | -2  | 4   | -1  | 2   | 1   | -5  | 4   |

***等等，需要每次都傻傻的回头看吗？？？***

根据题目要求：
1. 连续子数组
2. 累合最大

也就是说：我们只需要检查**前一个元素「子数组连续」**累合值得正负性，就能求出累合「负数越加越小」最大的结果。

d. index 4

前一个元素的累合值为：dp_map[4 - 1] = 4

满足我们的要求，加正数一定会得到一个更大的合。因此，此处应该是 4 + array[4] = 3

| index  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| array  | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |
| dp_map | -2  | 1   | -2  | 4   | 3   | 2   | 1   | -5  | 4   |

- ***realtion?***
检查前一个元素历史上能求出的最大合，根据其正负性选择是否将其拿进起来。

### 3. expr

- ***dp_map[i] represent what?***
从[0,i] ，i元素作为子数组的情况下最大的累合值
- ***dp_map[i] = ？***
case1: dp_map[i - 1] > 0 --> dp_map[i - 1] + array[i]
case1: dp_map[i - 1] < 0 -->  array[i]


***code***

```js
var maxSubArray = function(nums) {
    if(!nums || nums.length <= 0) {
        return -1;
    }
    const len = nums.length,
    dp = [...nums]; // 初始化（浅拷贝）

    for(let i = 1;i < len;i++) {
        if(dp[i - 1] < 0) {
            continue;
        }
        dp[i] = dp[i - 1] + nums[i]
    }

    return dp.reduce((memo,cur) => (cur > memo ? cur : memo),Number.MIN_SAFE_INTEGER)
};

```
